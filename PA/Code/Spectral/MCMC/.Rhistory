m=m+1
}
}
station=rep(1:(dim(Y1)[1]),each=npreds)
rmse=as.vector(RMSE[,1:(dim(Y1)[1])])
iterss=rep(1:npreds,(dim(Y1)[1]))
RMSES=data.frame(station,rmse,iterss)
RMSES$station=as.factor(RMSES$station)
station=seq(1:(dim(Y1)[1]))
cov=COV
COV.pr=data.frame(COV,station)
COV.pr$station=as.factor(COV.pr$station)
#RMSE
ggplot(RMSES)+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
ggplot(RMSES %>% filter(station%in%seq(1,40)))+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
p1=ggplot(RMSES)+geom_histogram(aes(x=rmse))+theme_bw()+ labs(x = "",y='')
p2=ggplot(RMSES)+geom_boxplot(aes(y=rmse))+theme_bw()
figureRMSE <- grid.arrange(p1, p2,ncol=2,top=textGrob("RMSE"))
#ggsave('RMSE.pdf',figureRMSE)
# COV pro
ggplot(COV.pr)+geom_boxplot(aes(y=cov))+theme_bw()
p3=ggplot(COV.pr)+geom_histogram(aes(x=cov))+theme_bw()
#ggsave('covP.pdf',p3)
rm(list = ls())
library(fields)
library(geoR)
library(truncnorm)
library(tidyverse)
library(mvtnorm)
library(gridExtra)
setwd("/Users/hongjianyang/Research/PAStudy/PA/Code/Spectral/MCMC/")
source('ExtraFunctions.R')
source('LMC_function.R')
#simulate data
source('simAllTS.R') # load your data here
# names(out)=c('rangeU','rangeV','sigmaU','sigmaV','tau1','tau2','A','Y1.m','Y2.m','Y1p')
# Real data are Y1.real and Y2.real
# Coordinates are coords1 and coords2
iters = 3000
burn=1000
exit = LMC_fit(Y1=Y1.real,Y2=Y2.real, s1=coords1,s2=coords2,sp1=NULL,sp2=NULL,
mean_range=0, sd_range=1, mean_var=0, sd_var=1, mean_rho=0,
sd_rho=10, iters=iters, burn=burn, thin=1, update=10)
range1 = exit$rangeU
range2 = exit$rangeV
sigma1 = exit$sigmaU
sigma2 = exit$sigmaV
tau1 = exit$tau1
tau2 = exit$tau2
Al = exit$A
range11 = mean(range1)
range21 = range2[, 1]
sigma11 = sigma1[, , 1]
sigma21 = sigma2[, , 1]
sigma1mean = colMeans(t(sigma11))
sigma2mean = colMeans(t(sigma21))
tau11 = tau1[, 1]
tau21 = tau2[, 1]
A = Al[, 1]
# try prediction block
rm(list = ls())
library(fields)
library(geoR)
library(truncnorm)
library(tidyverse)
library(mvtnorm)
library(gridExtra)
setwd("/Users/hongjianyang/Research/PAStudy/PA/Code/Spectral/MCMC/")
source('ExtraFunctions.R')
source('LMC_function.R')
#simulate data
source('simAllTS.R') # load your data here
# just check prediction (not inference)
#CV
K=5
npreds=50
Y1.pred= array(0,dim=c(nrow(Y1),ncol(Y1),npreds))
RMSE=matrix(0,npreds,dim(Y1)[1])
COV=numeric(dim(Y1)[1])
U <- rbind(u1, u2)
for (i in 1:(dim(Y1)[1]/K))
{
#set train and set sets of EPA data
which.test1=seq(1:dim(Y1)[1])[(K*(i-1)+1):(K*i)]
train.sites1=seq(1:dim(Y1)[1])[-which.test1]
train.sites2 = c(train.sites1, seq((dim(Y1)[1]+1),(dim(Y1)[1])+dim(Y2)[1]))
# Train-test split of locations
Y11 = u1[train.sites1,]
s11=s1[train.sites1,]
sp1=s1[which.test1,]
st1 = s1[train.sites1, ]
st2 = s2
# train set of PA (all)
Y22 = Y2
s22=s2
sp2=NULL # no test set
n1       <- nrow(Y11)
n2       <- nrow(Y22)
nt       <- ncol(Y11)
m1       <- is.na(Y11)
m2       <- is.na(Y22)
dv2 = as.matrix(dist(s22))
np1 = nrow(sp1)
np2  = nrow(sp2)
if (is.null(sp2))
{np2  = 0}
dp = as.matrix(dist(rbind(sp1,sp2)))
all.d=as.matrix(dist(rbind(st1,st2,sp1,sp2)))
Z1p = matrix(0,np1,nt)
# Kriging
Mp=exp_corr(all.d,range=rangeu)
Mp00=Mp[1:(n1+n2),1:(n1+n2)]
Mp11=Mp[(n1+n2+1):(n1+n2+np1+np2),(n1+n2+1):(n1+n2+np1+np2)]
Mp10=Mp[(n1+n2+1):(n1+n2+np1+np2),1:(n1+n2)]
Mp01=t(Mp10)
E00=eigen(Mp00)
E00.G=E00$vectors
E00.D=E00$values
Mp00.inv=E00.G%*%diag(1/E00.D)%*%t(E00.G)
AA=Mp10%*%Mp00.inv
a=Mp10%*%Mp00.inv%*%t(Mp10)
a=round(a,digits=7) # to avoid numercial underflow
B=Mp11-a
### sample U npreds times
for (j in 1:npreds)
{
Uls = matrix(0,n1+n2,nt)
# Ul is knwon
if (F) {
for (r in 1:nt)
{
Uls[,r]=t(chol(Mp00))%*%rnorm(n1+n2,0,sqrt(sigmau[r]))
}
}
U1p = matrix(0,np1,nt)
for (r in 1:nt)
{
Au=AA%*%as.matrix(U[train.sites2,r])
sigmaB=sigmau[r]*B
Ul.pred=rmvnorm(1,mean=Au,sigma=sigmaB)
U1p[,r]=Ul.pred[(1:np1)]
}
for(nn in 1:np1){Z1p[nn,] <- fft_real(U1p[nn,],inverse=TRUE)}
Y1.pred[which.test1,,j] <- beta.1+Z1p+rnorm(n=nt,sd=sqrt(tau1))
}
# Check prediction
for (k in 1:npreds)
{
a1=Y1.pred[which.test1,,k]
b1=Y1[which.test1,]
#RMSE
RMSE[k,(K*(i-1)+1):(K*i)]=sqrt(apply((a1-b1)^2,1,sum,na.rm=TRUE)/dim(a1)[2])
}
m=1
# Estimate coverage
for(k in which.test1)
{
samps=Y1.pred[m,,]
b=Y1[k,]
a=apply(samps,1,quantile,c(0.05,0.95))
cc=numeric(nt)
for (j in 1:nt)
{
cc[j]=between(b[j],a[1,j],a[2,j])
}
COV[k]=mean(cc,na.rm=TRUE)
m=m+1
}
}
station=rep(1:(dim(Y1)[1]),each=npreds)
rmse=as.vector(RMSE[,1:(dim(Y1)[1])])
iterss=rep(1:npreds,(dim(Y1)[1]))
RMSES=data.frame(station,rmse,iterss)
RMSES$station=as.factor(RMSES$station)
station=seq(1:(dim(Y1)[1]))
cov=COV
COV.pr=data.frame(COV,station)
COV.pr$station=as.factor(COV.pr$station)
#RMSE
ggplot(RMSES)+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
ggplot(RMSES %>% filter(station%in%seq(1,40)))+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
p1=ggplot(RMSES)+geom_histogram(aes(x=rmse))+theme_bw()+ labs(x = "",y='')
p2=ggplot(RMSES)+geom_boxplot(aes(y=rmse))+theme_bw()
figureRMSE <- grid.arrange(p1, p2,ncol=2,top=textGrob("RMSE"))
#ggsave('RMSE.pdf',figureRMSE)
# COV pro
ggplot(COV.pr)+geom_boxplot(aes(y=cov))+theme_bw()
p3=ggplot(COV.pr)+geom_histogram(aes(x=cov))+theme_bw()
#ggsave('covP.pdf',p3)
# simple Y vs Y pred plots
#pdf("real-predicted.pdf")
Station=2
n.pred=10
par(mfrow=c(5,5),mar=c(1,1,1,1))
for(i in 1:25)
{
Station=i
plot(Y1[,1],Y1.pred[,1,n.pred],xlab=c('real'),ylab=c('predicted'),asp=1)
abline(a=0,b=1)
}
#dev.off()
Station=2
n.pred=10
par(mfrow=c(5,5),mar=c(1,1,1,1))
for(i in 1:10)
{
Station=i
plot(Y1[,1],Y1.pred[,1,n.pred],xlab=c('real'),ylab=c('predicted'),asp=1)
abline(a=0,b=1)
}
#dev.off()
Station=2
n.pred=10
par(mfrow=c(3,3),mar=c(1,1,1,1))
for(i in 1:9)
{
Station=i
plot(Y1[,1],Y1.pred[,1,n.pred],xlab=c('real'),ylab=c('predicted'),asp=1)
abline(a=0,b=1)
}
#dev.off()
# try prediction block
rm(list = ls())
library(fields)
library(geoR)
library(truncnorm)
library(tidyverse)
library(mvtnorm)
library(gridExtra)
setwd("/Users/hongjianyang/Research/PAStudy/PA/Code/Spectral/MCMC/")
source('ExtraFunctions.R')
source('LMC_function.R')
#simulate data
source('simAllTS.R') # load your data here
# just check prediction (not inference)
#CV
K=5
npreds=50
Y1.pred= array(0,dim=c(nrow(Y1),ncol(Y1),npreds))
RMSE=matrix(0,npreds,dim(Y1)[1])
COV=numeric(dim(Y1)[1])
U <- rbind(u1, u2)
for (i in 1:(dim(Y1)[1]/K))
{
#set train and set sets of EPA data
which.test1=seq(1:dim(Y1)[1])[(K*(i-1)+1):(K*i)]
train.sites1=seq(1:dim(Y1)[1])[-which.test1]
train.sites2 = c(train.sites1, seq((dim(Y1)[1]+1),(dim(Y1)[1])+dim(Y2)[1]))
# Train-test split of locations
Y11 = u1[train.sites1,]
s11=s1[train.sites1,]
sp1=s1[which.test1,]
st1 = s1[train.sites1, ]
st2 = s2
# train set of PA (all)
Y22 = Y2
s22=s2
sp2=NULL # no test set
n1       <- nrow(Y11)
n2       <- nrow(Y22)
nt       <- ncol(Y11)
m1       <- is.na(Y11)
m2       <- is.na(Y22)
dv2 = as.matrix(dist(s22))
np1 = nrow(sp1)
np2  = nrow(sp2)
if (is.null(sp2))
{np2  = 0}
dp = as.matrix(dist(rbind(sp1,sp2)))
all.d=as.matrix(dist(rbind(st1,st2,sp1,sp2)))
Z1p = matrix(0,np1,nt)
# Kriging
Mp=exp_corr(all.d,range=rangeu)
Mp00=Mp[1:(n1+n2),1:(n1+n2)]
Mp11=Mp[(n1+n2+1):(n1+n2+np1+np2),(n1+n2+1):(n1+n2+np1+np2)]
Mp10=Mp[(n1+n2+1):(n1+n2+np1+np2),1:(n1+n2)]
Mp01=t(Mp10)
E00=eigen(Mp00)
E00.G=E00$vectors
E00.D=E00$values
Mp00.inv=E00.G%*%diag(1/E00.D)%*%t(E00.G)
AA=Mp10%*%Mp00.inv
a=Mp10%*%Mp00.inv%*%t(Mp10)
a=round(a,digits=7) # to avoid numercial underflow
B=Mp11-a
### sample U npreds times
for (j in 1:npreds)
{
Uls = matrix(0,n1+n2,nt)
# Ul is knwon
if (F) {
for (r in 1:nt)
{
Uls[,r]=t(chol(Mp00))%*%rnorm(n1+n2,0,sqrt(sigmau[r]))
}
}
U1p = matrix(0,np1,nt)
for (r in 1:nt)
{
Au=AA%*%as.matrix(U[train.sites2,r])
sigmaB=sigmau[r]*B
Ul.pred=rmvnorm(1,mean=Au,sigma=sigmaB)
U1p[,r]=Ul.pred[(1:np1)]
}
for(nn in 1:np1){Z1p[nn,] <- fft_real(U1p[nn,],inverse=TRUE)}
Y1.pred[which.test1,,j] <- beta.1+Z1p+rnorm(n=nt,sd=sqrt(tau1))
}
# Check prediction
for (k in 1:npreds)
{
a1=Y1.pred[which.test1,,k]
b1=Y1[which.test1,]
#RMSE
RMSE[k,(K*(i-1)+1):(K*i)]=sqrt(apply((a1-b1)^2,1,sum,na.rm=TRUE)/dim(a1)[2])
}
m=1
# Estimate coverage
for(k in which.test1)
{
samps=Y1.pred[m,,]
b=Y1[k,]
a=apply(samps,1,quantile,c(0.05,0.95))
cc=numeric(nt)
for (j in 1:nt)
{
cc[j]=between(b[j],a[1,j],a[2,j])
}
COV[k]=mean(cc,na.rm=TRUE)
m=m+1
}
}
station=rep(1:(dim(Y1)[1]),each=npreds)
rmse=as.vector(RMSE[,1:(dim(Y1)[1])])
iterss=rep(1:npreds,(dim(Y1)[1]))
RMSES=data.frame(station,rmse,iterss)
RMSES$station=as.factor(RMSES$station)
station=seq(1:(dim(Y1)[1]))
cov=COV
COV.pr=data.frame(COV,station)
COV.pr$station=as.factor(COV.pr$station)
#RMSE
ggplot(RMSES)+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
ggplot(RMSES %>% filter(station%in%seq(1,40)))+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
p1=ggplot(RMSES)+geom_histogram(aes(x=rmse))+theme_bw()+ labs(x = "",y='')
p2=ggplot(RMSES)+geom_boxplot(aes(y=rmse))+theme_bw()
figureRMSE <- grid.arrange(p1, p2,ncol=2,top=textGrob("RMSE"))
#ggsave('RMSE.pdf',figureRMSE)
# COV pro
ggplot(COV.pr)+geom_boxplot(aes(y=cov))+theme_bw()
p3=ggplot(COV.pr)+geom_histogram(aes(x=cov))+theme_bw()
#ggsave('covP.pdf',p3)
# simple Y vs Y pred plots
#pdf("real-predicted.pdf")
Station=2
n.pred=10
par(mfrow=c(3,3),mar=c(1,1,1,1))
for(i in 1:9)
{
Station=i
plot(Y1[,1],Y1.pred[,1,n.pred],xlab=c('real'),ylab=c('predicted'),asp=1)
abline(a=0,b=1)
}
#dev.off()
Y1
mean(Y1)
max(Y1)
min(Y1)
sd(as.vector(Y1))
source('ExtraFunctions.R')
#### simulation of the time series process
library(tidyverse)
library(spBayes)
library(ggplot2)
library(mgcv)
library(MASS)
library(mvtnorm)
library(truncnorm)
library(viridis)
# correlation function
exp_corr=function(d,range)
{
out=exp(-d/range)
return(out)
}
###### set some parameters ########
n=c(300,200) # number of locations
nt=5 # total time steps
tau1=1^2 # error variance1
tau2=(1.5)^2  # error variance2
set.seed(99)
al=runif(nt,min=5,max=10)
# correlation parameters
set.seed(88)
sigmau=seq(from=100,to=1,length=10)+rnorm(nt,sd=2)
set.seed(564)
sigmav=seq(from=10,to=.1,length=10)+rtruncnorm(nt,a=0,sd=.2)
# same range for all freq
rangeu=0.15
lrangeu=log(rangeu)
rangev=0.2
lrangev=log(rangev)
## mean
beta.1=0
beta.2=0
###### simulate coordinates #######
set.seed(22)
coords1 = cbind(runif(n[1],0,1), runif(n[1],0,1))
coords2 = cbind(runif(n[2],0,1), runif(n[2],0,1))
coords=rbind(coords1,coords2)
######## Get U and V ##########
du12=as.matrix(dist(coords)) #distance matrix U
u=matrix(NA,ncol=nt,nrow=sum(n))
u1=matrix(NA,ncol=nt,nrow=n[1])
u2=matrix(NA,ncol=nt,nrow=n[2])
v2=matrix(NA,ncol=nt,nrow=n[2])
dv2=as.matrix(dist(coords2)) # distance matrix v
M=exp_corr(du12,range=rangeu)
Sigmav22=exp_corr(dv2,range = rangev)
for (t in 1:nt)
{
#u
#M=exp_corr(du12,range=rangeu[t])
u[,t]=t(chol(M))%*%rnorm(sum(n),0,sqrt(sigmau[t]))
u1[,t]=u[(1:n[1]),t]
u2[,t]=u[(n[1]+1):(sum(n)),t]
#v
#Sigmav22=exp_corr(dv2,range = rangev[t])
v2[,t]=t(chol(Sigmav22))%*%rnorm(n[2],0,sqrt(sigmav[t]))
}
####### simulate response Y ############
#spectral
Z1sp=matrix(NA,ncol=nt,nrow=n[1])
Z2sp=matrix(NA,ncol=nt,nrow=n[2])
for (t in 1:nt)
{
Z1sp[,t]=u1[,t]#+rnorm(n[1],0,sqrt(nt*tau1))
Z2sp[,t]=al[t]*u2[,t]+v2[,t]#+rnorm(n[2],0,sqrt(nt*tau2))
}
#time domain
Y1=matrix(NA,ncol=nt,nrow=n[1])
Y2=matrix(NA,ncol=nt,nrow=n[2])
for(i in 1:n[1]){Y1[i,] <- fft_real(Z1sp[i,],inverse=TRUE)+beta.1+rnorm(nt,0,sqrt(tau1))}
for(i in 1:n[2]){Y2[i,] <- fft_real(Z2sp[i,],inverse=TRUE)+beta.2+rnorm(nt,0,sqrt(tau2))}
Y1.real=Y1
Y2.real=Y2
## missing values
# Exclude missing values for testing purpose
if (F) {
miss1=list()
miss2=list()
set.seed(8923)
for (t in 1:nt)
{
miss1[[t]]=sample(1:n[1],ceiling(n[1]/6),replace=FALSE)
miss2[[t]]=sample(1:n[2],ceiling(n[2]/6),replace=FALSE)
Y1[miss1[[t]],t]=NA
Y2[miss2[[t]],t]=NA
}
}
###### set data frame and plot #######
time=rep(seq(1,nt),each=sum(n))
type=rep(c(rep('1',n[1]),rep('2',n[2])),nt)
Y=c(as.vector(Y1),as.vector(Y2))
Ys=c(as.vector(Z1sp),as.vector(Z2sp))
U=c(as.vector(u1),as.vector(u2))
V=c(rep(NA,n[1]*nt),as.vector(v2))
s1=rep(c(coords1[,1],coords2[,1]),nt)
s2=rep(c(coords1[,2],coords2[,2]),nt)
site=rep(seq(1:sum(n)),nt)
data=data.frame(time,type,Y,U,V,s1,s2,site, Ys)
s1=coords1
s2=coords2
type=c(rep('1',n[1]),rep('2',n[2]))
# plot some data
#spatial
ggplot(data %>% filter(time==1))+
geom_point(aes(x=s1,y=s2,col=Y))+
facet_grid(~type)+theme_bw()+coord_fixed(ratio = 1)+
ggtitle('Y values, time 1')+scale_colour_gradient(low="#22FF00", high="#FF0000")
ggplot(data %>% filter(time==2))+
geom_point(aes(x=s1,y=s2,col=Y))+
facet_grid(~type)+theme_bw()+coord_fixed(ratio = 1)+
ggtitle('Y values, time 2')+scale_colour_gradient(low="#22FF00", high="#FF0000")
ggplot(data %>% filter(time==3))+
geom_point(aes(x=s1,y=s2,col=Y))+
facet_grid(~type)+theme_bw()+coord_fixed(ratio = 1)+
ggtitle('Y values, time 3')+scale_colour_gradient(low="#22FF00", high="#FF0000")
ggplot(data %>% filter(time==4))+
geom_point(aes(x=s1,y=s2,col=Y))+
facet_grid(~type)+theme_bw()+coord_fixed(ratio = 1)+
ggtitle('Y values, time 4')+scale_colour_gradient(low="#22FF00", high="#FF0000")
#temporal
ggplot(data %>% filter(site %in%seq(1:20)))+geom_line(aes(x=time,y=Y))+facet_wrap(~site)+theme_bw()
# Plot U data
ggplot(data %>% filter(time==1))+
geom_point(aes(x=s1,y=s2,col=U))+
facet_grid(~type)+theme_bw()+coord_fixed(ratio = 1) + ggtitle('U values, time 1') +
scale_colour_gradient(low="#22FF00", high="#FF0000")
ggplot(data %>% filter(time==2))+
geom_point(aes(x=s1,y=s2,col=U))+
facet_grid(~type)+theme_bw()+coord_fixed(ratio = 1) + ggtitle('U values, time 2') +
scale_colour_gradient(low="#22FF00", high="#FF0000")
# Plot Ys (response value in spectral domain)
ggplot(data %>% filter(time==1))+
geom_point(aes(x=s1,y=s2,col=Ys))+
facet_grid(~type)+theme_bw()+coord_fixed(ratio = 1) + ggtitle('Spectral Y values, time 1') +
scale_colour_gradient(low="#22FF00", high="#FF0000")
# Plot Ys (response value in spectral domain)
ggplot(data %>% filter(time==2))+
geom_point(aes(x=s1,y=s2,col=Ys))+
facet_grid(~type)+theme_bw()+coord_fixed(ratio = 1) + ggtitle('Spectral Y values, time 2') +
scale_colour_gradient(low="#22FF00", high="#FF0000")
