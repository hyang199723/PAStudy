plot(largen, tvec[[2]], main = 'p = 500, n v.s. time', xlab = 'n', ylab = 'time')
plot(tvec[[1]], evec[[1]], main = 'p = 250, time v.s. error', xlab = 'time', ylab = 'error')
plot(tvec[[2]], evec[[2]], main = 'p = 500, time v.s. error', xlab = 'time', ylab = 'error')
k
p
iters
iter
iters = 50
largep <- c(250, 500)
largen <- c(2500, 5000, 7500, 10000)
# testing purpose
# Bookkeeping
tvec <- vector('list', 2)
evec <- vector('list', 2)
for (i in 1:2) {
p = largep[i]
for (j in 1:4) {
n = largen[j]
X = matrix(rnorm(n * p), nrow = n, ncol = p)
X1 = t(X) %*% X # X1 is X'X
start = proc.time()[3]
invX = X1
for (k in 1:p) {
invX = sweep(invX, k)
}
invX = -invX
end = proc.time()[3]
elaps = end - start
beta = as.vector(rep(1, p))
total_error = 0
for (iter in iters) {
Y = X %*% beta + as.vector(rnorm(n))
bhat = invX %*% t(X) %*% Y
error = t(beta - bhat) %*% (beta - bhat)
total_error = total_error + error
}
avgError = total_error / iters
evec[[i]][j] = avgError
tvec[[i]][j] = elaps
}
}
plot(largen, tvec[[1]], main = 'p = 250, n v.s. time', xlab = 'n', ylab = 'time')
plot(largen, tvec[[2]], main = 'p = 500, n v.s. time', xlab = 'n', ylab = 'time')
plot(tvec[[1]], evec[[1]], main = 'p = 250, time v.s. error', xlab = 'time', ylab = 'error')
plot(tvec[[2]], evec[[2]], main = 'p = 500, time v.s. error', xlab = 'time', ylab = 'error')
tvec
evec
plot(largen, tvec[[1]], main = 'p = 250, n v.s. time', xlab = 'n', ylab = 'time')
plot(largen, tvec[[2]], main = 'p = 500, n v.s. time', xlab = 'n', ylab = 'time')
plot(tvec[[1]], evec[[1]], main = 'p = 250, time v.s. error', xlab = 'time', ylab = 'error')
plot(tvec[[2]], evec[[2]], main = 'p = 500, time v.s. error', xlab = 'time', ylab = 'error')
tvec[[2]]
plot(largen[1:2], tvec[[2]], main = 'p = 500, n v.s. time', xlab = 'n', ylab = 'time')
dnorm(0)
pnorm(o)
pnorm(0)
beta = 0
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
k
beta
pnorm(beta)
qnorm(0.99)
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
beta - (pnorm(beta)-0.99) / dnorm(beta)
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -0.1
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -1
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -1.5
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -1.4
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 0
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 1
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = 0
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
pnorm(0)
beta = 1
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = 2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = 3
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = 4
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = -2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = -2
for (k in 1:3) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = -2
for (k in 1:2) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
library(invgamma)
rinvgamma(1,1,1)
mean(rinvgamma(1e4,1,1))
mean(rinvgamma(1e10,1,1))
mean(rinvgamma(1e8,1,1))
(0:64)/128
return(out)}
fft_real <- function(dat,inverse=FALSE){
if(!inverse){
x  <- dat
n  <- length(x)
n2 <- floor(n/2)
y  <- fft(x,inverse=FALSE)
# if n is even
if(n%%2==0){
X1     <- Re(y)[1:(n2+1)]
X2     <- Im(y)[2:(n2)]
}
# if n is odd
if(n%%2!=0){
X1     <- Re(y)[1:(n2+1)]
X2     <- Im(y)[2:(n2+1)]
}
out <- c(X1,X2)
}
if(inverse){
X  <- dat
n  <- length(X)
n2 <- floor(n/2)
if(n%%2==0){
Y1    <- c(X[1:(n2+1)],X[n2:2])
Y2    <- c(0,X[(n2+2):n],0,-X[n:(n2+2)])
}
if(n%%2!=0){
Y1    <- c(X[1:(n2+1)],X[(n2+1):2])
Y2    <- c(0,X[(n2+2):n],-X[n:(n2+2)])
}
y   <- complex(n, real = Y1, imaginary = Y2)
out <- Re(fft(y/n,inverse=TRUE))
}
return(out)}
a <- rnorm(50)
a
fft_real(a)
fft(a)
fft(a)/sqrt(50)
abs(fft(a)/sqrt(50))
plot(x = 1:50, y = a)
plot(x = 1:50, y = a, 'l')
fft(a)
mean(a)
fft(a) / sqrt(50)
mean(A)
mean(a)
fft_real(a)
mean(fft_real(a))
fft(a)
rm(list = ls())
# try prediction block
# Last update: 02/22/2022
setwd("/Users/hongjianyang/Research/PAStudy/PA/Code/Spectral/Hongjian")
library(fields)
library(geoR)
library(truncnorm)
library(tidyverse)
library(mvtnorm)
source('ExtraFunctions.R')
source('LMC_function.R')
#simulate data
source('simAllTS.R') # load your data here
RMSE=matrix(NA,ncol=dim(Y1)[1],nrow=2000)
COV=numeric(dim(Y1)[1])
iters=3000
burn=1000
#CV
5=10
for (i in 1:(dim(Y1)[1]/K)) {
#set train and set sets of EPA data
which.test1=seq(1:dim(Y1)[1])[(K*(i-1)+1):(K*i)]
train.sites1=seq(1:dim(Y1)[1])[-which.test1]
Y11 = Y1[train.sites1,]
s11=s1[train.sites1,]
sp1=s1[which.test1,]
# train set of PA (all)
Y22 = Y2
s22=s2
sp2=NULL # no test set
# fit model and predict
exit=LMC_fit(Y1=Y11,Y2=Y22, s1=s11,s2=s22,sp1=sp1,sp2=sp2,
mean_range=0, sd_range=1, mean_var=0, sd_var=1, mean_rho=0,
sd_rho=10, iters=iters, burn=burn, thin=1, update=10)
# Check prediction
for (k in 2:(iters-burn))
{
a1=exit$Y1p[,,k]
b1=Y1[which.test1,]
#RMSE
RMSE[k,(K*(i-1)+1):(K*i)]=sqrt(apply((a1-b1)^2,1,sum,na.rm=TRUE)/dim(a1)[2])
}
# Estimate coverage
for(k in (K*(i-1)+1):(K*i))
{
n.site=k
samps=exit$Y1p[n.site,,]
b=Y1[n.site,]
a=apply(samps,1,quantile,c(0.05,0.95))
cc=numeric(nt)
for (j in 1:nt)
{
cc[j]=between(b[j],a[1,j],a[2,j])
}
COV[n.site]=mean(cc,na.rm=TRUE)
}
#print(i)
}
# get data frame to plot
station=rep(1:40,each=2000)
rmse=as.vector(RMSE[,1:40])
iterss=rep(1:2000,40)
RMSES=data.frame(station,rmse,iterss)
RMSES$station=as.factor(RMSES$station)
ggplot(RMSES)+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
rm(list = ls())
# try prediction block
# Last update: 02/22/2022
setwd("/Users/hongjianyang/Research/PAStudy/PA/Code/Spectral/Hongjian")
library(fields)
library(geoR)
library(truncnorm)
library(tidyverse)
library(mvtnorm)
source('ExtraFunctions.R')
source('LMC_function.R')
#simulate data
source('simAllTS.R') # load your data here
RMSE=matrix(NA,ncol=dim(Y1)[1],nrow=2000)
COV=numeric(dim(Y1)[1])
iters=3000
burn=1000
#CV
K=10
for (i in 1:(dim(Y1)[1]/K)) {
#set train and set sets of EPA data
which.test1=seq(1:dim(Y1)[1])[(K*(i-1)+1):(K*i)]
train.sites1=seq(1:dim(Y1)[1])[-which.test1]
Y11 = Y1[train.sites1,]
s11=s1[train.sites1,]
sp1=s1[which.test1,]
# train set of PA (all)
Y22 = Y2
s22=s2
sp2=NULL # no test set
# fit model and predict
exit=LMC_fit(Y1=Y11,Y2=Y22, s1=s11,s2=s22,sp1=sp1,sp2=sp2,
mean_range=0, sd_range=1, mean_var=0, sd_var=1, mean_rho=0,
sd_rho=10, iters=iters, burn=burn, thin=1, update=10)
# Check prediction
for (k in 2:(iters-burn))
{
a1=exit$Y1p[,,k]
b1=Y1[which.test1,]
#RMSE
RMSE[k,(K*(i-1)+1):(K*i)]=sqrt(apply((a1-b1)^2,1,sum,na.rm=TRUE)/dim(a1)[2])
}
# Estimate coverage
for(k in (K*(i-1)+1):(K*i))
{
n.site=k
samps=exit$Y1p[n.site,,]
b=Y1[n.site,]
a=apply(samps,1,quantile,c(0.05,0.95))
cc=numeric(nt)
for (j in 1:nt)
{
cc[j]=between(b[j],a[1,j],a[2,j])
}
COV[n.site]=mean(cc,na.rm=TRUE)
}
#print(i)
}
# get data frame to plot
station=rep(1:40,each=2000)
rmse=as.vector(RMSE[,1:40])
iterss=rep(1:2000,40)
RMSES=data.frame(station,rmse,iterss)
RMSES$station=as.factor(RMSES$station)
ggplot(RMSES)+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
rm(list = ls())
# try prediction block
# Last update: 02/22/2022
setwd("/Users/hongjianyang/Research/PAStudy/PA/Code/Spectral/Hongjian")
library(fields)
library(geoR)
library(truncnorm)
library(tidyverse)
library(mvtnorm)
source('ExtraFunctions.R')
source('LMC_function.R')
#simulate data
source('simAllTS.R') # load your data here
RMSE=matrix(NA,ncol=dim(Y1)[1],nrow=2000)
COV=numeric(dim(Y1)[1])
iters=3000
burn=1000
#CV
K=5
for (i in 1:(dim(Y1)[1]/K)) {
#set train and set sets of EPA data
which.test1=seq(1:dim(Y1)[1])[(K*(i-1)+1):(K*i)]
train.sites1=seq(1:dim(Y1)[1])[-which.test1]
Y11 = Y1[train.sites1,]
s11=s1[train.sites1,]
sp1=s1[which.test1,]
# train set of PA (all)
Y22 = Y2
s22=s2
sp2=NULL # no test set
# fit model and predict
exit=LMC_fit(Y1=Y11,Y2=Y22, s1=s11,s2=s22,sp1=sp1,sp2=sp2,
mean_range=0, sd_range=1, mean_var=0, sd_var=1, mean_rho=0,
sd_rho=10, iters=iters, burn=burn, thin=1, update=10)
# Check prediction
for (k in 2:(iters-burn))
{
a1=exit$Y1p[,,k]
b1=Y1[which.test1,]
#RMSE
RMSE[k,(K*(i-1)+1):(K*i)]=sqrt(apply((a1-b1)^2,1,sum,na.rm=TRUE)/dim(a1)[2])
}
# Estimate coverage
for(k in (K*(i-1)+1):(K*i))
{
n.site=k
samps=exit$Y1p[n.site,,]
b=Y1[n.site,]
a=apply(samps,1,quantile,c(0.05,0.95))
cc=numeric(nt)
for (j in 1:nt)
{
cc[j]=between(b[j],a[1,j],a[2,j])
}
COV[n.site]=mean(cc,na.rm=TRUE)
}
print(i)
}
# get data frame to plot
station=rep(1:40,each=2000)
rmse=as.vector(RMSE[,1:40])
iterss=rep(1:2000,40)
RMSES=data.frame(station,rmse,iterss)
RMSES$station=as.factor(RMSES$station)
ggplot(RMSES)+geom_boxplot(aes(y=rmse,x=station))+theme_bw()
