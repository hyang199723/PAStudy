beta = 0
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
k
beta
pnorm(beta)
qnorm(0.99)
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
beta - (pnorm(beta)-0.99) / dnorm(beta)
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = rnorm(1)
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -0.1
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -1
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -1.5
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = -1.4
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 0
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 1
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-3) {
break
}
}
beta = 2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = 0
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
pnorm(0)
beta = 1
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = 2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = 3
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = 4
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = -2
for (k in 1:1e5) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = -2
for (k in 1:3) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
beta = -2
for (k in 1:2) {
beta = beta - (pnorm(beta)-0.99) / dnorm(beta)
if (abs(pnorm(beta) - 0.99) < 1e-5) {
break
}
}
library(invgamma)
rinvgamma(1,1,1)
mean(rinvgamma(1e4,1,1))
mean(rinvgamma(1e10,1,1))
mean(rinvgamma(1e8,1,1))
(0:64)/128
return(out)}
fft_real <- function(dat,inverse=FALSE){
if(!inverse){
x  <- dat
n  <- length(x)
n2 <- floor(n/2)
y  <- fft(x,inverse=FALSE)
# if n is even
if(n%%2==0){
X1     <- Re(y)[1:(n2+1)]
X2     <- Im(y)[2:(n2)]
}
# if n is odd
if(n%%2!=0){
X1     <- Re(y)[1:(n2+1)]
X2     <- Im(y)[2:(n2+1)]
}
out <- c(X1,X2)
}
if(inverse){
X  <- dat
n  <- length(X)
n2 <- floor(n/2)
if(n%%2==0){
Y1    <- c(X[1:(n2+1)],X[n2:2])
Y2    <- c(0,X[(n2+2):n],0,-X[n:(n2+2)])
}
if(n%%2!=0){
Y1    <- c(X[1:(n2+1)],X[(n2+1):2])
Y2    <- c(0,X[(n2+2):n],-X[n:(n2+2)])
}
y   <- complex(n, real = Y1, imaginary = Y2)
out <- Re(fft(y/n,inverse=TRUE))
}
return(out)}
a <- rnorm(50)
a
fft_real(a)
fft(a)
fft(a)/sqrt(50)
abs(fft(a)/sqrt(50))
plot(x = 1:50, y = a)
plot(x = 1:50, y = a, 'l')
fft(a)
mean(a)
fft(a) / sqrt(50)
mean(A)
mean(a)
fft_real(a)
mean(fft_real(a))
fft(a)
# This script is for computationally intense tasks that runs on high performance machine
# All data and source files need to be stored under the same directory
# This includes the main LMC functions
# This script has two functions, LMC_fit and compact.LMC_fit
# Last update: 12/01/2021
# Script to apply LMC functions to real data
# Last update: 12/01/2021
rm(list=ls())
# Set working directory to current
library(rstudioapi)
curpath = dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(curpath)
library(fields)
library(glue)
library(viridis)
#library(geoR)
library(truncnorm)
library(tidyr)
library(mvtnorm)
source('ExtraFunctions.R')
source('LMC_function.R')
OR = as.POSIXct('1970-01-01', tz = 'UTC')
########################
#### Simulated data ####
########################
#source('simAllTS.R')
####################
#### Real Data #####
####################
PA_raw <- read.csv("PA_2020_Hourly_Formatted.csv")
FRM_raw <- read.csv("FRM_2020_Hourly_Formatted.csv")
PA_raw <- PA_raw[order(PA_raw$Timestamp), ]
FRM_raw <- FRM_raw[order(FRM_raw$Timestamp), ]
PA_data <- PA_raw
FRM_data <- FRM_raw
# Convert timestamp
# Note: We need to convert time to EST to avoid NA time issue
# For PA data, there is no missingness after conversion
# However, for FRM data, there are 20 missing values
PA_data$Timestamp <- as.POSIXct(PA_raw$Timestamp, tz = 'EST', format = "%Y-%m-%d %H:%M:%OS")
FRM_data$Timestamp <- as.POSIXct(FRM_raw$Timestamp, tz= 'EST', format = "%Y-%m-%d %H:%M:%OS")
# Get rid of missingness in FRM
FRM_data <- FRM_data[!is.na(FRM_data$Timestamp), ]
# Complete Purple Air timestamps
time <- unique(PA_data$Timestamp)
int.seq <- as.numeric(time) / 3600
int.start = int.seq[1]
int.end = int.seq[length(int.seq)]
complete = int.start:int.end
pa.missing = complete[!(complete %in% int.seq)]
time.missing = as.POSIXct(pa.missing * 3600, origin = OR)
lon = PA_data[1,1]
lat = PA_data[1,2]
df <- data.frame(Lon = lon, Lat = lat, Timestamp = time.missing, PM25 = NA)
PA.complete = rbind(PA_data, df)
# Complete FRM data
time <- unique(FRM_data$Timestamp)
int.seq <- as.numeric(time) / 3600
int.start = int.seq[1]
int.end = int.seq[length(int.seq)]
complete = int.start:int.end
frm.missing = complete[!(complete %in% int.seq)]
time.missing = as.POSIXct(frm.missing * 3600, origin = OR)
lon = FRM_data[1,1]
lat = FRM_data[1,2]
df <- data.frame(Lon = lon, Lat = lat, Timestamp = rep(time.missing, each = length(lon)), PM25 = NA)
FRM.complete = rbind(FRM_data, df)
# Check NAs in PA and FRM data
sum(is.na(PA.complete$Timestamp))
sum(is.na(FRM.complete$Timestamp))
start = as.POSIXct('2020-03-01 05:00:00')
end = as.POSIXct('2020-03-03 23:00:00') # 67 timstamps/spectrums Oct 2 FRM stations OCt 1 - 7
interval = (as.numeric(end) - as.numeric(start)) / 3600
print(interval + 1)
pa <- subset(PA.complete, (Timestamp >= start) & (Timestamp <= end))
frm <- subset(FRM.complete, (Timestamp >= start) & (Timestamp <= end))
# Get data to desired format
frmTS <- pivot_wider(frm, names_from = Timestamp, values_from = PM25)
paTS <- pivot_wider(pa, names_from = Timestamp, values_from = PM25)
dim(frmTS)
dim(paTS)
# Record locations of PA and FRM stations
s1 <- as.matrix(frmTS[, 1:2])
s2 <- as.matrix(paTS[, 1:2])
# Get rid of the locations
frmTS <- frmTS[, -c(1:2)]
paTS <- paTS[, -c(1:2)]
Y1 = as.matrix(data.frame(frmTS))
colnames(Y1)=NULL
Y2 = as.matrix(data.frame(paTS))
colnames(Y2)=NULL
#####################
### Fit the model ###
#####################
#exit2=Compact.LMC_fit(Y1,Y2, s1,s2,iters=6000)
#2042.504--> simudata
start = proc.time()[3]
exit1 = LMC_fit(Y1, Y2, s1, s2, iters = 3000, thin = 1)
end = proc.time()[3]
#2389.701
# This script is for computationally intense tasks that runs on high performance machine
# All data and source files need to be stored under the same directory
# This includes the main LMC functions
# This script has two functions, LMC_fit and compact.LMC_fit
# Last update: 12/01/2021
# Script to apply LMC functions to real data
# Last update: 12/01/2021
rm(list=ls())
# Set working directory to current
library(rstudioapi)
curpath = dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(curpath)
library(fields)
library(glue)
library(viridis)
#library(geoR)
library(truncnorm)
library(tidyr)
library(mvtnorm)
source('ExtraFunctions.R')
source('LMC_function.R')
OR = as.POSIXct('1970-01-01', tz = 'UTC')
########################
#### Simulated data ####
########################
#source('simAllTS.R')
####################
#### Real Data #####
####################
PA_raw <- read.csv("PA_2020_Hourly_Formatted.csv")
FRM_raw <- read.csv("FRM_2020_Hourly_Formatted.csv")
PA_raw <- PA_raw[order(PA_raw$Timestamp), ]
FRM_raw <- FRM_raw[order(FRM_raw$Timestamp), ]
PA_data <- PA_raw
FRM_data <- FRM_raw
# Convert timestamp
# Note: We need to convert time to EST to avoid NA time issue
# For PA data, there is no missingness after conversion
# However, for FRM data, there are 20 missing values
PA_data$Timestamp <- as.POSIXct(PA_raw$Timestamp, tz = 'EST', format = "%Y-%m-%d %H:%M:%OS")
FRM_data$Timestamp <- as.POSIXct(FRM_raw$Timestamp, tz= 'EST', format = "%Y-%m-%d %H:%M:%OS")
# Get rid of missingness in FRM
FRM_data <- FRM_data[!is.na(FRM_data$Timestamp), ]
# Complete Purple Air timestamps
time <- unique(PA_data$Timestamp)
int.seq <- as.numeric(time) / 3600
int.start = int.seq[1]
int.end = int.seq[length(int.seq)]
complete = int.start:int.end
pa.missing = complete[!(complete %in% int.seq)]
time.missing = as.POSIXct(pa.missing * 3600, origin = OR)
lon = PA_data[1,1]
lat = PA_data[1,2]
df <- data.frame(Lon = lon, Lat = lat, Timestamp = time.missing, PM25 = NA)
PA.complete = rbind(PA_data, df)
# Complete FRM data
time <- unique(FRM_data$Timestamp)
int.seq <- as.numeric(time) / 3600
int.start = int.seq[1]
int.end = int.seq[length(int.seq)]
complete = int.start:int.end
frm.missing = complete[!(complete %in% int.seq)]
time.missing = as.POSIXct(frm.missing * 3600, origin = OR)
lon = FRM_data[1,1]
lat = FRM_data[1,2]
df <- data.frame(Lon = lon, Lat = lat, Timestamp = rep(time.missing, each = length(lon)), PM25 = NA)
FRM.complete = rbind(FRM_data, df)
# Check NAs in PA and FRM data
sum(is.na(PA.complete$Timestamp))
sum(is.na(FRM.complete$Timestamp))
start = as.POSIXct('2020-03-01 05:00:00')
end = as.POSIXct('2020-03-03 23:00:00') # 67 timstamps/spectrums Oct 2 FRM stations OCt 1 - 7
interval = (as.numeric(end) - as.numeric(start)) / 3600
print(interval + 1)
pa <- subset(PA.complete, (Timestamp >= start) & (Timestamp <= end))
frm <- subset(FRM.complete, (Timestamp >= start) & (Timestamp <= end))
# Get data to desired format
frmTS <- pivot_wider(frm, names_from = Timestamp, values_from = PM25)
paTS <- pivot_wider(pa, names_from = Timestamp, values_from = PM25)
dim(frmTS)
dim(paTS)
# Record locations of PA and FRM stations
s1 <- as.matrix(frmTS[, 1:2])
s2 <- as.matrix(paTS[, 1:2])
# Get rid of the locations
frmTS <- frmTS[, -c(1:2)]
paTS <- paTS[, -c(1:2)]
Y1 = as.matrix(data.frame(frmTS))
colnames(Y1)=NULL
Y2 = as.matrix(data.frame(paTS))
colnames(Y2)=NULL
#####################
### Fit the model ###
#####################
#exit2=Compact.LMC_fit(Y1,Y2, s1,s2,iters=6000)
#2042.504--> simudata
start = proc.time()[3]
exit1 = LMC_fit(Y1, Y2, s1, s2, iters = 3000, thin = 1)
end = proc.time()[3]
#2389.701
exit1$Y1.m
a <- exit1$Y1.m
a <- as.matrix(exit1$Y1.m)
View(a)
typeof(exit1$Y1.m)
dim(exit1$Y1.m)
# Get Y1 and Y2
y1.raw <- exit1$Y1.m
y2.raw <- exit1$Y2.m
# Get Y1 and Y2
y1.raw <- exit1$Y1.m
y2.raw <- exit1$Y2.m
colMeans(y1.raw)
a <- colMeans(y1.raw)
dim(a)
# Get Y1 and Y2
y1.raw <- exit1$Y1.m[,,,1]
y2.raw <- exit1$Y2.m[,,,1]
dim(y1.raw)
a <- colMeans(y1.raw)
dim(a)
a <- mean(y1.raw, axis = 3)
#2042.504--> simudata
start = proc.time()[3]
iters = 6000
thin = 1
exit1 = LMC_fit(Y1, Y2, s1, s2, iters = iters, thin = thin)
end = proc.time()[3]
#2389.701
# Get Y1 and Y2
burnin = 2000
y1.raw <- exit1$Y1.m[,,burnin:iters,1]
y2.raw <- exit1$Y2.m[,,burnin:iters,1]
# Get Y1 and Y2
burnin = 2000
y1.raw <- exit1$Y1.m[,,burnin:iters,1]
y2.raw <- exit1$Y2.m[,,burnin:iters,1]
y1.complete = rowMeans(y1.raw, dims = 2)
y2.complete = rowMeans(y2.raw, dims = 2)
View(y1.complete)
View(Y1)
y1.complete = rowMeans(y1.raw, dims = 2)
y2.complete = rowMeans(y2.raw, dims = 2)
write.csv(y1.complete, 'EPA_Imputed_2020.csv')
write.csv(y2.complete, 'PA_Imputed_2020.csv')
## Make plots of missing values for a few stations
# First, make plots for EPA stations
y1.miss <- is.na(Y1)
y2.miss <- is.na(Y2)
y1.miss
library(ggplot2)
